// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: countries.sql

package dbx

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createCountry = `-- name: CreateCountry :one
INSERT INTO countries (id, name, status, created_at, updated_at)
VALUES ( uuid_generate_v4(), $1, $2, now(), now())
    RETURNING id, name, status, created_at, updated_at
`

type CreateCountryParams struct {
	Name   string          `json:"name"`
	Status CountryStatuses `json:"status"`
}

// $1 = name, $2 = status
func (q *Queries) CreateCountry(ctx context.Context, arg CreateCountryParams) (Country, error) {
	row := q.db.QueryRow(ctx, createCountry, arg.Name, arg.Status)
	var i Country
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCountryByID = `-- name: GetCountryByID :one
SELECT id, name, status, created_at, updated_at
FROM countries
WHERE id = $1
`

func (q *Queries) GetCountryByID(ctx context.Context, id uuid.UUID) (Country, error) {
	row := q.db.QueryRow(ctx, getCountryByID, id)
	var i Country
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCountryByName = `-- name: GetCountryByName :one
SELECT id, name, status, created_at, updated_at
FROM countries
WHERE name = $1
`

func (q *Queries) GetCountryByName(ctx context.Context, name string) (Country, error) {
	row := q.db.QueryRow(ctx, getCountryByName, name)
	var i Country
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const searchBeNameAndStatuses = `-- name: SearchBeNameAndStatuses :many
WITH base AS (
    SELECT
        c.id, c.name, c.status, c.created_at, c.updated_at,
        COUNT(*) OVER() AS total_count
    FROM countries c
    WHERE
        c.name ILIKE $3
    AND (
    $4::country_statuses[] IS NULL
    OR cardinality($4::country_statuses[]) = 0
    OR c.status = ANY($4::country_statuses[])
    )
    )
SELECT id, name, status, created_at, updated_at, total_count
FROM base
ORDER BY created_at DESC, id
    LIMIT  $2::int8
OFFSET (GREATEST($1::int8, 1) - 1) * $2::int8
`

type SearchBeNameAndStatusesParams struct {
	Page        int64             `json:"page"`
	PageSize    int64             `json:"page_size"`
	NamePattern string            `json:"name_pattern"`
	Statuses    []CountryStatuses `json:"statuses"`
}

type SearchBeNameAndStatusesRow struct {
	ID         uuid.UUID        `json:"id"`
	Name       string           `json:"name"`
	Status     CountryStatuses  `json:"status"`
	CreatedAt  pgtype.Timestamp `json:"created_at"`
	UpdatedAt  pgtype.Timestamp `json:"updated_at"`
	TotalCount int64            `json:"total_count"`
}

// Ищем страны по имени + (опционально) по массиву статусов
func (q *Queries) SearchBeNameAndStatuses(ctx context.Context, arg SearchBeNameAndStatusesParams) ([]SearchBeNameAndStatusesRow, error) {
	rows, err := q.db.Query(ctx, searchBeNameAndStatuses,
		arg.Page,
		arg.PageSize,
		arg.NamePattern,
		arg.Statuses,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchBeNameAndStatusesRow
	for rows.Next() {
		var i SearchBeNameAndStatusesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCountryName = `-- name: UpdateCountryName :one
UPDATE countries
SET name = $2,
    updated_at = now()
WHERE id = $1
    RETURNING id, name, status, created_at, updated_at
`

type UpdateCountryNameParams struct {
	ID   uuid.UUID `json:"id"`
	Name string    `json:"name"`
}

// $1 = country_id, $2 = new name
func (q *Queries) UpdateCountryName(ctx context.Context, arg UpdateCountryNameParams) (Country, error) {
	row := q.db.QueryRow(ctx, updateCountryName, arg.ID, arg.Name)
	var i Country
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCountryStatus = `-- name: UpdateCountryStatus :one
UPDATE countries
SET status = $2,
    updated_at = now()
WHERE id = $1
    RETURNING id, name, status, created_at, updated_at
`

type UpdateCountryStatusParams struct {
	ID     uuid.UUID       `json:"id"`
	Status CountryStatuses `json:"status"`
}

// $1 = country_id, $2 = status
func (q *Queries) UpdateCountryStatus(ctx context.Context, arg UpdateCountryStatusParams) (Country, error) {
	row := q.db.QueryRow(ctx, updateCountryStatus, arg.ID, arg.Status)
	var i Country
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
