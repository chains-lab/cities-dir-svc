// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: city_gov.sql

package dbx

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createCityGov = `-- name: CreateCityGov :one
INSERT INTO city_governments (user_id, city_id, role, created_at, updated_at)
VALUES ($1, $2, $3, now(), now())
    RETURNING user_id, city_id, role, created_at, updated_at
`

type CreateCityGovParams struct {
	UserID uuid.UUID    `json:"user_id"`
	CityID uuid.UUID    `json:"city_id"`
	Role   CityGovRoles `json:"role"`
}

// $user_id, $city_id, $role
func (q *Queries) CreateCityGov(ctx context.Context, arg CreateCityGovParams) (CityGovernment, error) {
	row := q.db.QueryRow(ctx, createCityGov, arg.UserID, arg.CityID, arg.Role)
	var i CityGovernment
	err := row.Scan(
		&i.UserID,
		&i.CityID,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteCityAdmin = `-- name: DeleteCityAdmin :exec
DELETE FROM city_governments
WHERE city_id = $1
  AND role = 'admin'
`

// $city_id
func (q *Queries) DeleteCityAdmin(ctx context.Context, cityID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteCityAdmin, cityID)
	return err
}

const deleteCityGov = `-- name: DeleteCityGov :exec
DELETE FROM city_governments
WHERE user_id = $1
  AND city_id = $2
`

type DeleteCityGovParams struct {
	UserID uuid.UUID `json:"user_id"`
	CityID uuid.UUID `json:"city_id"`
}

// $user_id, $city_id
func (q *Queries) DeleteCityGov(ctx context.Context, arg DeleteCityGovParams) error {
	_, err := q.db.Exec(ctx, deleteCityGov, arg.UserID, arg.CityID)
	return err
}

const getCityAdmin = `-- name: GetCityAdmin :one
SELECT user_id, city_id, role, created_at, updated_at
FROM city_governments
WHERE city_id = $1
  AND role = 'admin'
`

// $city_id
func (q *Queries) GetCityAdmin(ctx context.Context, cityID uuid.UUID) (CityGovernment, error) {
	row := q.db.QueryRow(ctx, getCityAdmin, cityID)
	var i CityGovernment
	err := row.Scan(
		&i.UserID,
		&i.CityID,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCityGov = `-- name: GetCityGov :one
SELECT user_id, city_id, role, created_at, updated_at
FROM city_governments
WHERE user_id = $1
  AND city_id = $2
`

type GetCityGovParams struct {
	UserID uuid.UUID `json:"user_id"`
	CityID uuid.UUID `json:"city_id"`
}

// $user_id, $city_id
func (q *Queries) GetCityGov(ctx context.Context, arg GetCityGovParams) (CityGovernment, error) {
	row := q.db.QueryRow(ctx, getCityGov, arg.UserID, arg.CityID)
	var i CityGovernment
	err := row.Scan(
		&i.UserID,
		&i.CityID,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const selectCityGovs = `-- name: SelectCityGovs :many
WITH base AS (
    SELECT
        cg.user_id, cg.city_id, cg.role, cg.created_at, cg.updated_at,
        COUNT(*) OVER() AS total_count
    FROM city_governments cg
    WHERE cg.city_id = $3
)
SELECT user_id, city_id, role, created_at, updated_at, total_count
FROM base
ORDER BY
    CASE WHEN role = 'admin' THEN 0 ELSE 1 END,
    created_at DESC
    LIMIT  $2::int8
OFFSET (GREATEST($1::int8, 1) - 1) * $2::int8
`

type SelectCityGovsParams struct {
	Page     int64     `json:"page"`
	PageSize int64     `json:"page_size"`
	CityID   uuid.UUID `json:"city_id"`
}

type SelectCityGovsRow struct {
	UserID     uuid.UUID        `json:"user_id"`
	CityID     uuid.UUID        `json:"city_id"`
	Role       CityGovRoles     `json:"role"`
	CreatedAt  pgtype.Timestamp `json:"created_at"`
	UpdatedAt  pgtype.Timestamp `json:"updated_at"`
	TotalCount int64            `json:"total_count"`
}

// $city_id, $page, $page_size
// Пагинация + сортировка: сначала admin, потом moderator; внутри — по created_at DESC
func (q *Queries) SelectCityGovs(ctx context.Context, arg SelectCityGovsParams) ([]SelectCityGovsRow, error) {
	rows, err := q.db.Query(ctx, selectCityGovs, arg.Page, arg.PageSize, arg.CityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectCityGovsRow
	for rows.Next() {
		var i SelectCityGovsRow
		if err := rows.Scan(
			&i.UserID,
			&i.CityID,
			&i.Role,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
