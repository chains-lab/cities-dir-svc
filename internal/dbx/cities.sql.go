// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: cities.sql

package dbx

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/paulmach/orb"
)

const createCity = `-- name: CreateCity :one
INSERT INTO city (id, country_id, status, zone, icon, slug, timezone, created_at, updated_at)
VALUES (
        uuid_generate_v4(),  -- $1
        $1,
        $2,
        ST_SetSRID(ST_GeomFromGeoJSON($3), 4326),  -- MultiPolygon GeoJSON
        $4,
        $5,
        $6,
        now(),
        now()
       )
    RETURNING id, country_id, status, zone, icon, slug, timezone, created_at, updated_at
`

type CreateCityParams struct {
	CountryID         uuid.UUID    `json:"country_id"`
	Status            CityStatuses `json:"status"`
	StGeomfromgeojson interface{}  `json:"st_geomfromgeojson"`
	Icon              string       `json:"icon"`
	Slug              string       `json:"slug"`
	Timezone          string       `json:"timezone"`
}

// $1=id, $2=country_id, $3=status, $4=zone_geojson, $5=icon, $6=slug, $7=timezone
func (q *Queries) CreateCity(ctx context.Context, arg CreateCityParams) (City, error) {
	row := q.db.QueryRow(ctx, createCity,
		arg.CountryID,
		arg.Status,
		arg.StGeomfromgeojson,
		arg.Icon,
		arg.Slug,
		arg.Timezone,
	)
	var i City
	err := row.Scan(
		&i.ID,
		&i.CountryID,
		&i.Status,
		&i.Zone,
		&i.Icon,
		&i.Slug,
		&i.Timezone,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCityByID = `-- name: GetCityByID :one
SELECT id, country_id, status, zone, icon, slug, timezone, created_at, updated_at
FROM city
WHERE id = $1
`

func (q *Queries) GetCityByID(ctx context.Context, id uuid.UUID) (City, error) {
	row := q.db.QueryRow(ctx, getCityByID, id)
	var i City
	err := row.Scan(
		&i.ID,
		&i.CountryID,
		&i.Status,
		&i.Zone,
		&i.Icon,
		&i.Slug,
		&i.Timezone,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCityBySlug = `-- name: GetCityBySlug :one
SELECT id
FROM city
WHERE slug = $1
`

func (q *Queries) GetCityBySlug(ctx context.Context, slug string) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, getCityBySlug, slug)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getCityWithDetails = `-- name: GetCityWithDetails :one
SELECT
    c.id,
    c.country_id,
    c.status,
    c.zone,
    c.icon,
    c.slug,
    c.timezone,
    c.created_at,
    c.updated_at,
    d.language,
    d.name
FROM city c
         JOIN city_details d
              ON d.city_id = c.id
WHERE c.id = $1
  AND d.language = $2
`

type GetCityWithDetailsParams struct {
	ID       uuid.UUID     `json:"id"`
	Language CityLanguages `json:"language"`
}

type GetCityWithDetailsRow struct {
	ID        uuid.UUID        `json:"id"`
	CountryID uuid.UUID        `json:"country_id"`
	Status    CityStatuses     `json:"status"`
	Zone      orb.MultiPolygon `json:"zone"`
	Icon      string           `json:"icon"`
	Slug      string           `json:"slug"`
	Timezone  string           `json:"timezone"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
	Language  CityLanguages    `json:"language"`
	Name      string           `json:"name"`
}

// $1 = city_id (uuid), $2 = language (city_languages)
func (q *Queries) GetCityWithDetails(ctx context.Context, arg GetCityWithDetailsParams) (GetCityWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getCityWithDetails, arg.ID, arg.Language)
	var i GetCityWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.CountryID,
		&i.Status,
		&i.Zone,
		&i.Icon,
		&i.Slug,
		&i.Timezone,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Language,
		&i.Name,
	)
	return i, err
}

const getNearestCity = `-- name: GetNearestCity :one
WITH p AS (
    SELECT ST_SetSRID(ST_MakePoint($1, $2), 4326)::geometry(Point,4326) AS pt
)
SELECT c.id
FROM city c, p
ORDER BY
    CASE WHEN ST_Contains(c.zone, p.pt) THEN 0 ELSE 1 END,
    c.zone <-> p.pt    -- KNN, требует GIST-индекса на city.zone
LIMIT 1
`

type GetNearestCityParams struct {
	StMakepoint   interface{} `json:"st_makepoint"`
	StMakepoint_2 interface{} `json:"st_makepoint_2"`
}

func (q *Queries) GetNearestCity(ctx context.Context, arg GetNearestCityParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, getNearestCity, arg.StMakepoint, arg.StMakepoint_2)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const selectCityDetailsByNames = `-- name: SelectCityDetailsByNames :many
WITH matched AS (
    SELECT cd.city_id, cd.language, cd.name
    FROM city_details cd
    WHERE cd.name ILIKE $3
    ),
    base AS (
SELECT
    cd.city_id,
    cd.language,
    cd.name,
    COUNT(*) OVER() AS total_count
FROM matched cd
    JOIN city c ON c.id = cd.city_id
WHERE
    (
    $4::city_statuses[] IS NULL
   OR cardinality($4::city_statuses[]) = 0
   OR c.status = ANY($4::city_statuses[])
    )
  AND
    (
    $5::uuid[] IS NULL
   OR cardinality($5::uuid[]) = 0
   OR c.country_id = ANY($5::uuid[])
    )
    )
SELECT city_id, language, name, total_count
FROM base
ORDER BY name, city_id
LIMIT $2::int8
OFFSET (GREATEST($1::int8, 1) - 1) * $2::int8
`

type SelectCityDetailsByNamesParams struct {
	Page        int64          `json:"page"`
	PageSize    int64          `json:"page_size"`
	NamePattern string         `json:"name_pattern"`
	Statuses    []CityStatuses `json:"statuses"`
	CountryIds  []uuid.UUID    `json:"country_ids"`
}

type SelectCityDetailsByNamesRow struct {
	CityID     uuid.UUID     `json:"city_id"`
	Language   CityLanguages `json:"language"`
	Name       string        `json:"name"`
	TotalCount int64         `json:"total_count"`
}

// $1 = name_pattern (например '%roma%')
// $2 = statuses (city_statuses[])  -- NULL или '{}' => без фильтра
// $3 = country_ids (uuid[])        -- NULL или '{}' => без фильтра
// $4 = page
// $5 = size
// Возвращаем: city_id, language, name, total_count
func (q *Queries) SelectCityDetailsByNames(ctx context.Context, arg SelectCityDetailsByNamesParams) ([]SelectCityDetailsByNamesRow, error) {
	rows, err := q.db.Query(ctx, selectCityDetailsByNames,
		arg.Page,
		arg.PageSize,
		arg.NamePattern,
		arg.Statuses,
		arg.CountryIds,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectCityDetailsByNamesRow
	for rows.Next() {
		var i SelectCityDetailsByNamesRow
		if err := rows.Scan(
			&i.CityID,
			&i.Language,
			&i.Name,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCityCenter = `-- name: UpdateCityCenter :exec
UPDATE city
SET center = ST_SetSRID(ST_MakePoint($2, $3), 4326),
    updated_at = now()
WHERE id = $1
`

type UpdateCityCenterParams struct {
	ID            uuid.UUID   `json:"id"`
	StMakepoint   interface{} `json:"st_makepoint"`
	StMakepoint_2 interface{} `json:"st_makepoint_2"`
}

// $1 = city_id (uuid), $2 = lon (float8), $3 = lat (float8)
func (q *Queries) UpdateCityCenter(ctx context.Context, arg UpdateCityCenterParams) error {
	_, err := q.db.Exec(ctx, updateCityCenter, arg.ID, arg.StMakepoint, arg.StMakepoint_2)
	return err
}

const updateCityIcon = `-- name: UpdateCityIcon :exec
UPDATE city
SET icon = $2,
    updated_at = now()
WHERE id = $1
`

type UpdateCityIconParams struct {
	ID   uuid.UUID `json:"id"`
	Icon string    `json:"icon"`
}

// $1 = city_id (uuid), $2 = icon (varchar)
func (q *Queries) UpdateCityIcon(ctx context.Context, arg UpdateCityIconParams) error {
	_, err := q.db.Exec(ctx, updateCityIcon, arg.ID, arg.Icon)
	return err
}

const updateCitySlug = `-- name: UpdateCitySlug :exec
UPDATE city
SET slug = $2,
    updated_at = now()
WHERE id = $1
`

type UpdateCitySlugParams struct {
	ID   uuid.UUID `json:"id"`
	Slug string    `json:"slug"`
}

// $1 = city_id (uuid), $2 = slug (varchar, UNIQUE)
func (q *Queries) UpdateCitySlug(ctx context.Context, arg UpdateCitySlugParams) error {
	_, err := q.db.Exec(ctx, updateCitySlug, arg.ID, arg.Slug)
	return err
}

const updateCityStatus = `-- name: UpdateCityStatus :exec
UPDATE city
SET status = $2,
    updated_at = now()
WHERE id = $1
`

type UpdateCityStatusParams struct {
	ID     uuid.UUID    `json:"id"`
	Status CityStatuses `json:"status"`
}

// $1 = city_id (uuid), $2 = status (city_statuses)
func (q *Queries) UpdateCityStatus(ctx context.Context, arg UpdateCityStatusParams) error {
	_, err := q.db.Exec(ctx, updateCityStatus, arg.ID, arg.Status)
	return err
}

const updateCityTimezone = `-- name: UpdateCityTimezone :exec
UPDATE city
SET timezone = $2,
    updated_at = now()
WHERE id = $1
`

type UpdateCityTimezoneParams struct {
	ID       uuid.UUID `json:"id"`
	Timezone string    `json:"timezone"`
}

// $1 = city_id (uuid), $2 = timezone (varchar, IANA)
func (q *Queries) UpdateCityTimezone(ctx context.Context, arg UpdateCityTimezoneParams) error {
	_, err := q.db.Exec(ctx, updateCityTimezone, arg.ID, arg.Timezone)
	return err
}

const updateCityZone = `-- name: UpdateCityZone :exec
UPDATE city
SET zone   = ST_SetSRID(ST_GeomFromGeoJSON($2), 4326),
    updated_at = now()
WHERE id = $1
`

type UpdateCityZoneParams struct {
	ID                uuid.UUID   `json:"id"`
	StGeomfromgeojson interface{} `json:"st_geomfromgeojson"`
}

// $1 = city_id (uuid), $2 = zone (text, MultiPolygon in GeoJSON)
func (q *Queries) UpdateCityZone(ctx context.Context, arg UpdateCityZoneParams) error {
	_, err := q.db.Exec(ctx, updateCityZone, arg.ID, arg.StGeomfromgeojson)
	return err
}
